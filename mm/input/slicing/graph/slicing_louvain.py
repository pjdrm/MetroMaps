'''
Provides the interface for the specific Louvain algorithm
to be used for word community detection.

To use this algorithm, in the .yaml configuration write the name of this module.
(slicing: type: slicing_louvain)

The Louvain algorithm is sensible to weighted edges. These weights
are generated by classes in the weight package. The specific
weighting scheme can be configured in "slicing: weight_calculator:"
attribute of the yaml configuration file. 

@author: Mota
'''
import mm.input.slicing.graph.slicing_graph_based as slicing_graph_based
from itertools import combinations
from itertools import chain
import igraph as ig
import louvain
from mm.input.slicing.graph.weight.factory import factory

class SlicingLouvain(slicing_graph_based.SlicingGraphBased):
    def __init__(self, legacy_helper_config_dict):
        super(SlicingLouvain, self).__init__(legacy_helper_config_dict)
        self.token_to_node_dic = {}
        self.node_to_token_dic = {}
        self.token_tfidfscores = {}
        self.g = self.createGraph()
        self.weightcalc = factory(legacy_helper_config_dict, self)
        self.weightcalc.calculateWeights()
        
    def getTokenid(self, nodeIndex):
        return self.node_to_token_dic[nodeIndex]
    
    def addTokenid(self, tokenid, nodeIndex):
        self.node_to_token_dic[nodeIndex] = tokenid
    
    def getNodeid(self, tokenid):
        return self.token_to_node_dic[tokenid]
    
    def addNodeIndex(self, tokenid, nodeIndex):
        self.token_to_node_dic[tokenid] = nodeIndex
        
    '''
    The Louvain algorithm is part of the igraph package.
    Therefore, this class overrides the super method createGraph
    to generate the appropriate type of graph.
    
    TODO: create graph wrapper classes to deal with this issue
    '''
    def createGraph(self):
        
        token_ids_list = []
        
        '''
        Calculating which words will be part of the graph
        '''
        for doc_id in self.doc_keys:
            token_ids = []
            token_tfidf = {}
            for token_id in self.doc_counts[doc_id]:
                if self.doc_counts[doc_id][token_id] < self.min_freq_in_doc:
                    continue
                
                tfidf_score = self.tfidf(token_id, doc_id)
                token_tfidf[token_id] = tfidf_score    
                      
                if not int(token_id) in self.token_tfidfscores:
                    self.token_tfidfscores[int(token_id)] = []
                self.token_tfidfscores[int(token_id)].append(tfidf_score)
                
                
            token_ids = sorted(token_tfidf, key=lambda x : -token_tfidf[x])[:self.max_tokens]
            token_ids_list.append(token_ids)
            
        '''
        Generation of the co-occurrence graph.
        The token_to_node_dic and node_to_token_dic variables
        are used to convert from indexes of nodes in the graph
        and word indexes.
        '''
        n_nodes = len(set(chain(*token_ids_list)))
        g = ig.Graph(n_nodes)
        nodeIndex = 0
        for token_ids in token_ids_list:
            for (token_1, token_2) in combinations(token_ids,2):
                int_token1 = int(token_1) 
                int_token2 = int(token_2)
                
                if not int_token1 in self.token_to_node_dic:
                    self.addTokenid(int_token1, nodeIndex)
                    self.addNodeIndex(int_token1, nodeIndex)
                    intnode1 = nodeIndex
                    nodeIndex += 1
                else:
                    intnode1 = self.getNodeid(int_token1)
                    
                if not int_token2 in self.token_to_node_dic:
                    self.addTokenid(int_token2, nodeIndex)
                    self.addNodeIndex(int_token2, nodeIndex)
                    intnode2 = nodeIndex
                    nodeIndex += 1
                else:
                    intnode2 = self.getNodeid(int_token2)
                
                '''
                The 'count' attribute specifies how many times two words
                co-occured in different documents. The attribute is used
                by weight calculator classes.
                '''
                if not (intnode1, intnode2) in g.get_edgelist():
                    g.add_edges([(intnode1, intnode2)])
                    edgeid = g.get_eid(intnode1, intnode2)
                    g.es[edgeid]['count'] = 1.0
                else:
                    edgeid = g.get_eid(intnode1, intnode2)
                    w = g.es[edgeid]['count']
                    g.es[edgeid]['count'] = w + 1.0        
        return g
    
    '''
    Filters communities that have less elements than the minSize
    parameter.
    
    Note: this method was initially used for filtering communities with
    size 1. Since the graph to be analyzed has the appropriate
    number of nodes (no extra and isolated nodes) this seems not to
    be a problem.
    '''
    def filterCommunities(self, communities_list, minSize):
        comms_filtered = []
        for comm in communities_list:
            if len(comm['cluster_tokens']) <  minSize:
                continue
            comms_filtered.append(comm)
        return comms_filtered
         
    def getCommunities(self, vertexCluster):
        node_membership = vertexCluster.membership
        communities_list = [{'cluster_tokens' : [], 'k' : 5} for i in range(max(node_membership)+1)]
        for node_index, com_index in enumerate(node_membership):
            communities_list[com_index]['cluster_tokens'].append(self.token_to_word[self.node_to_token_dic[node_index]])
            
        comms_filtered = self.filterCommunities(communities_list, 2)
        return comms_filtered
        
    def louvain(self):
        vertexCluster = louvain.find_partition(self.g, method='Modularity', weight='weight');
        return self.getCommunities(vertexCluster)
    
    def run(self):
        return self.louvain()
    
def construct(config):
    return SlicingLouvain(config)  
